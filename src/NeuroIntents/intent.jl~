struct Correlation <: ContinuousUnivariateDistribution end

struct ZScore <: ContinuousUnivariateDistribution end
struct PValue <: ContinuousUnivariateDistribution end
struct LogPValue <: ContinuousUnivariateDistribution end
struct Log10PValue <: ContinuousUnivariateDistribution end
struct ParametricEstimate <: ContinuousUnivariateDistribution
    p1::Any
    p2::Any
    p3::Any
end

const StatP0 = Union{Correlation,ZScore,PValue,LogPValue,Log10PValue}
const StatP1 = Union{TDist,Chi,Chisq,Poisson}
const StatP2 = Union{FDist,Beta,Binomial,Gamma,Normal,NoncentralT,NoncentralChisq,Logistic,Uniform}
const StatP3 = Union{NoncentralF,GeneralizedExtremeValue,ParametricEstimate}

struct CustomLabels end
struct NeuroNames end
struct DisplacementVector end
struct Dimensionless end


struct NoIntent end
const NiftiIntents = Dict{Int, Type}(
    0    => NoIntent,
    # spm intent
    2    => Correlation,
    3    => TDist,
    4    => FDist,
    5    => ZScore,
    6    => Chisq,
    7    => Beta,
    8    => Binomial,
    9    => Gamma,
    10   => Poisson,
    11   => Normal,
    12   => NoncentralF,
    13   => NoncentralChisq,
    14   => Logistic,
    15   => Laplace,
    16   => Uniform,
    17   => NoncentralT,
    18   => Weibull,
    19   => Chi,
    20   => InverseGaussian,
    21   => GeneralizedExtremeValue,
    22   => PValue,
    23   => LogPValue,
    24   => Log10PValue,

    1001 => ParametricEstimate,
    1002 => CustomLabels,
    1003 => NeuroNames,
    1004 => SMatrix,
    1005 => Symmetric,
    1006 => DisplacementVector,
    1007 => SVector,
    1008 => Point,
    1009 => Triangle,
    1010 => Quat,
    1011 => Dimensionless,
  )

const NiftiIntentsReverse = Dict{Type,Int16}()
for (k, v) in NiftiIntents
    NiftiIntentsReverse[v] = k
end

function decodeintent(i::Integer)
    if i < 1
        return UnkownIntent
    elseif i < 1000
        decodestatsintent(i)
    elseif i < 2000
        decodestructintent(i)
    elseif i < 3000
        decodegiftiintent(i)
    elseif i < 4000
        decodeciftiintent(i)
    else
        return UnkownIntent
    end
end

#intent(img::ImageMeta{T,N,A,ImageProperties{:NII}}) where {T,N,A} = intent(properties(img))
intent(s::ImageStream) = intent(properties(s))

#intent(p::ImageProperties) = intent(header(p))
#intent(p::ImageProperties{:header}) = @get p "intent" NoIntent
intent(::Nothing) = NoIntent

intent(A::AbstractArray{T}) where {T<:BitTypes} = NoIntent

intent(A::AbstractArray{<:RGB}) = NoIntent
intent(A::AbstractArray{<:RGBA}) = NoIntent

intent(A::AbstractArray{<:Quat}) = Quat
intent(A::AbstractArray{<:SVector}) = SVector
intent(A::AbstractArray{<:SMatrix}) = SMatrix
intent(A::AbstractArray{T}) where {T<:Union{StatP0,StatP1,StatP2,StatP3}} = T
intent(A::AbstractArray{<:Point}) = Point
intent(A::AbstractArray{<:Triangle}) = Triangle
intent(A::AbstractVector{<:RGB}) = GiftiRGB
intent(A::AbstractVector{<:RGBA}) = GiftiRGBA

# TODO
# CustomLabels
# NeuroNames
#intent(A::IndirectArray) = CustomLabels

# TODO
# Dimensionless
# GiftiTimeSeries
# GiftiShape)

# array dimensions are in row major form



intentaxis(s::AbstractArray, ::Type) = Axis{:dim5}(range(Float64(1), step=s.pixdim[5], length=s.size[5]))
intentaxis(s::AbstractArray, ::Type{SMatrix}) = [Axis{:col}(range(1, length=intentparams(s)[2])), Axis{:row}(range(1, length=intentparams(s)[2]))]
intentaxis(s::AbstractArray, ::Type{Triangle}) = Axis{:triangledim}(1:3)
intentaxis(s::AbstractArray, ::Type{Point}) = Axis{:pointdim}(1:3)
intentaxis(s::AbstractArray, ::Type{GiftiNodeIndex}) = Axis{:pointdim}(1:3)
intentaxis(s::AbstractArray, ::Type{Quat}) = Axis{:quatdim}(1:4)
intentaxis(s::AbstractArray, ::Type{DisplacementVector}) = Axis{:vecdim}(range(1, length=s.size[5]))
intentaxis(s::AbstractArray, ::Type{SVector}) = Axis{:vecdim}(range(1, length=s.size[5]))
intentaxis(s::AbstractArray, ::Type{GiftiRGB}) = Axis{:colordim}(1:3)
intentaxis(s::AbstractArray, ::Type{GiftiRGBA}) = Axis{:colordim}(1:4)


intentaxis(s, pixdim, ::Type) = Axis{:dim5}(range(Float64(1), step=pixdim[5], length=size[5]))
intentaxis(s, pixdim, ::Type{SMatrix}) = [Axis{:col}(Base.OneTo(intentparams(s)[2])), Axis{:row}(Base.OneTo(intentparams(s)[1]))]
intentaxis(s, pixdim, ::Type{Triangle}) = Axis{:triangledim}(1:3)
intentaxis(s, pixdim, ::Type{Point}) = Axis{:pointdim}(1:3)
intentaxis(s, pixdim, ::Type{GiftiNodeIndex}) = Axis{:pointdim}(1:3)
intentaxis(s, pixdim, ::Type{Quat}) = Axis{:quatdim}(1:4)
intentaxis(s, pixdim, ::Type{DisplacementVector}) = Axis{:vecdim}(range(1, length=s.size[5]))
intentaxis(s, pixdim, ::Type{SVector}) = Axis{:vecdim}(range(1, length=s.size[5]))
intentaxis(s, pixdim, ::Type{GiftiRGB}) = Axis{:colordim}(1:3)
intentaxis(s, pixdim, ::Type{GiftiRGBA}) = Axis{:colordim}(1:4)


function guessintent(ext::Vector{AbstractString}, ::Type{A}) where {A<:AbstractArray}
    if ext[end] == "gz"  # CIfTI and GIfTI aren't supposed to be zipped
        return A
    elseif ext[end] == "nii"
        elseif ext[end-1] == "dconn"
            return ConnDense
        elseif ext[end-1] == "dtseries"
            return ConnDenseSeries
        elseif ext[end-1] == "pconn"
            return ConnParcels
        elseif ext[end-1] == "ptseries"
            return ConnParcelSries
        elseif ext[end-1] == "dscalar"
            return ConnDenseScalar
        elseif ext[end-1] == "dlabel"
            return ConnDenseLabel
        elseif ext[end-1] == "pscalar"
            return ConnParcelScalr
        elseif ext[end-1] == "pdconn"
            return ConnParcelDense
        elseif ext[end-1] == "dpconn"
            return ConnDenseParcel
        elseif ext[end-1] == "pconnscalar"
            return ConnPPSc
        elseif ext[end-1] == "dfan"
            return FiberFan
        elseif ext[end-1] == "dfansamp"
            return FanSamples
        else
            return A  # assume no meaningful extra extension was present
        end
    elseif ext[end] == "gii"
            if ext[end-1] == "coord"
            return GiftiCoordinate
        elseif ext[end-1] == "func"
            return GiftiFunctional
        elseif ext[end-1] == "label"
            return GiftiLabel
        elseif ext[end-1] == "rgba"
            return GiftiRGBA
        elseif ext[end-1] == "shape"
            return GiftiShape
        elseif ext[end-1] == "surf"
            return GiftiSurface
        elseif ext[end-1] == "tensor"
            return GiftiTensor
        elseif ext[end-1] == "time"
            return GiftiTime
        elseif ext[end-1] == "topo"
            return GiftiTopology
        elseif ext[end-1] == "vector"
            return GiftiVector
        elseif ext[end] == "gii"
            return GIfTI
        end
    end
end
